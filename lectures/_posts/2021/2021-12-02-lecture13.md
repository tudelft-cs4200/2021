---
layout: talk
title: "Lecture 13: Implementing Register Allocation & Control Flow & Memory Management"
tag: lecture
categories: []
kind: Lecture
series: lectures
speaker: Eelco Visser
authors:
pdf: /lectures/2021/13-control-flow/CS4200-2021-13-control-flow.pdf
image: /lectures/2021/13-control-flow/CS4200-2021-13-control-flow/CS4200-2021-13-control-flow.011.png
talkURL:
eventURL:
event:
references: []
permalink: /lecture/13
redirect_from:
- /lecture/13
---

### Implementing Register Allocation

Last week we looked at the approach for using graph coloring for register allocation, conceptually.
This week we study Stratego code for implementing register allocation (for straigh line code).
Register allocation consists of liveness analysis, building an interference graph from the results of that analysis, coloring the nodes of that graph, and finally applying the coloring result to the program.

### Control Flow

We extend our compiler to handle boolean values and control flow constructs in the subject language.
By desugaring the language we can reduce the constructs that the downstream compiler has to consider.

### Memory Management

We make a start with the safety considerations of memory management and consider automated memory management techniques.
We study a range of garbage collection algorithms and study their properties.
To be continued next week.

Slides:
- [PDF](/2021/lectures/2021/13-control-flow/CS4200-2021-13-memory-management.pdf)

<img src="/2021/lectures/2021/13-control-flow/CS4200-2021-13-memory-management/CS4200-2021-13-memory-management.022.png" class="border border-dark" />

### References

See the memory management slide for references.



<!-- In this lecture we study further code generation techniques.

### Calling Conventions

We first study functions in ChocoPy and the operational semantics rules that define their meaning.
Then we look at activation records, what motivates their existence, and how they are used to implement function calls.
We reconstruct the RISC-V calling convention described in the ChocoPy language implementation guide, looking in detail at the implementation of an example caller and callee.

### Dynamic Rewrite Rules

In the second part of the lecture, we study dynamic rewrite rules in Stratego, which can be used to define context-sensitive transformations. We look at examples for keeping track of stack offsets, and mapping variables to their offsets. See the paper by Bravenboer et al. (2006) for more information about dynamic rules.

### Code Generation Mechanics

In the third part of the lecture, we take a broader look at mechanics for code generation, the properties we would like compilers to adhere to, and to what extend existing mechanisms support the verification of those properties out of the box.

- Code generation by string manipulation
  - Stratego does support string templates, which can be useful to do quick code generation
- Code generation by term transformation
  - This is what we do in this course. A
- Guaranteeing syntactic correct target code
  - By means of type checking terms against signature; coming up for Stratego [SLE 2020]
- Program transformation with concrete object syntax
  - Quoting concrete syntax, while transforming the underlying abstract syntax; see [GPCE 2002, OOPSLA 2004, SCP 2010]
- Hygienic transformations (avoiding name capture)
  - Hygienic macros in Scheme/Racket ensure capture avoidance in binding constructs introduced by macros
  - The namefix approach guarantees capture avoidance by checking after the fact
  - We are working on avoiding capture in rename refactoring based on scope graphs
- Guaranteeing type correct target code
  - In intrinsically-typed interpreters/compilers, the type safety of the transformation is guaranteed by construction; see [POPL 2018, 2021] for explorations of this approach in Agda
- Preservation of dynamic semantics
  - The CompCert certified compiler proves that its code generation preserves the semantics of the source language in target programs; a challenge is how to realize such certified compilation with minimal effort

We only briefly touch on these topics. See the references for further information. -->
